#!/usr/bin/env python

import roslib; roslib.load_manifest('cob_hardware_test')

import sys
import thread
import threading
import time
import unittest

import rospy
import rostest

import rosunit

NAME = 'hztest'

from threading import Thread

#run tests in one test with all results in a list
#!/usr/bin/env python

# modified from http://bit.ly/dEyw03
import rospy
import rostest
import time
import rosunit
import sys

NAME = 'hztest'
import unittest


class Result:    
    def __init__(self, test_name, topic):
        self.topic = topic
        self.topic = test_name
        self.message_received = False
        # Count of all messages received
        self.msg_count = 0
        # Time of first message received
        self.msg_t0 = -1.0
        # Time of last message received
        self.msg_tn = -1.0
        
        self.errors = []
        
        self.min_interval = -1
        self.max_interval = -1


class HzTest(unittest.TestCase):
    def __init__(self, *args):
        super(HzTest, self).__init__(*args)
        rospy.init_node(NAME)
        #self.maxDiff = None
        self.lock = threading.Lock()
    pass
    def setUp(self):
        self.verificationErrors = []
        
    def tearDown(self):
        self.assertEqual([], self.verificationErrors)       
               
    def callback(self, msg, result):
        # flag that message has been received
        result.message_received = True         
        try:
            #self.lock.acquire()
            self.wall_clock = False
            if self.wall_clock:
                curr = time.time()
            else:
                curr_rostime = rospy.get_rostime()

                #print "CURR ROSTIME", curr_rostime.to_sec()
                
                if curr_rostime.is_zero():
                    return
                curr = curr_rostime.to_sec()
 
            if result.msg_t0 <= 0.0 or result.msg_t0 > curr:
                result.msg_t0 = curr
                result.msg_count = 1
                last = 0
            else:
                result.msg_count += 1
                last = result.msg_tn

            result.msg_tn = curr

            # If we're instructed to check each inter-message interval, do
            self.check_intervals = False
            # so
            if self.check_intervals and last > 0:
                interval = curr - last
                if interval < result.min_interval:
                    print >> sys.stderr, "CURR", curr
                    print >> sys.stderr, "LAST", last
                    print >> sys.stderr, "msg_count", result.msg_count
                    print >> sys.stderr, "msg_tn", result.msg_tn
                    result.errors.append(
                        'min_interval exceeded: %s [actual] vs. %s [min]'%\
                        (interval, result.min_interval))
                # If max_interval is <= 0.0, then we have no max
                elif result.max_interval > 0.0 and interval > result.max_interval:
                    result.errors.append(
                        'max_interval exceeded: %s [actual] vs. %s [max]'%\
                        (interval, result.max_interval))

        finally:
            #self.lock.release() 
            pass   
            
#modified from https://gist.github.com/brantfaircloth/764363            
def create_dynamic_method(test_name, topic, hz, hzerror, test_duration, wait_time):
    """just don't include `test` in the function name here, nose will try to
    run it"""
    def dynamic_test_method(self):
    
        result = Result(test_name, topic)
        
        current_test_failed = False
        result.message_received = False
        

        

        if hz == 0:
            min_rate = 0.0
            max_rate = 0.0
            result.min_interval = 0.0
            result.max_interval = 0.0
        else:
            min_rate = hz - hzerror
            max_rate = hz + hzerror
            result.min_interval = 1.0 / max_rate
            if min_rate <= 0.0:
                result.max_interval = 0.0
            else:
                result.max_interval = 1.0 / min_rate

        # Start actual test
        sub = rospy.Subscriber(topic, rospy.AnyMsg, self.callback, result)
        try: self.assert_(not result.errors, "bad initialization state (errors)")
        except AssertionError, e:
            if not current_test_failed:
                self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                current_test_failed = True
        
        print "Waiting for messages"
        # we have to wait until the first message is received before measuring the rate
        # as time can advance too much before publisher is up
        
        # - give the test 20 seconds to start, may parameterize this in the future
        wallclock_timeout_t = time.time() + wait_time
        while not result.message_received and time.time() < wallclock_timeout_t:
            time.sleep(0.1)
            
        print 'TOPIC: %r ' % (result.topic)
        
        if hz > 0.:
            try: self.assert_(result.message_received, "no messages before timeout")
            except AssertionError, e:
                if not current_test_failed:
                    self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                    current_test_failed = True
        else:
            try: self.failIf(message_received, "message received")
            except AssertionError, e:
                if not current_test_failed:
                    self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                    current_test_failed = True
            
        print "Starting rate measurement"
        if self.wall_clock:
            timeout_t = time.time() + test_duration
            while time.time() < timeout_t:
                time.sleep(0.1)
        else:
            timeout_t = rospy.get_time() + test_duration
            while rospy.get_time() < timeout_t:
                rospy.sleep(0.1)
        print "Done waiting, validating results"
        sub.unregister()

        # Check that we got at least one message
        if hz > 0:
            try: self.assert_(result.msg_count > 0, "no messages received")
            except AssertionError, e:
                if not current_test_failed:
                    self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                    current_test_failed = True
        else:
            try: self.assertEquals(0, result.msg_count)
            except AssertionError, e:
                if not current_test_failed:
                    self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                    current_test_failed = True
        # Check whether inter-message intervals were violated (if we were
        # checking them)
        try: self.assert_(not result.errors, '\n'.join(result.errors))
        except AssertionError, e:
            if not current_test_failed:
                self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                current_test_failed = True
                

        # If we have a non-zero rate target, make sure that we hit it on
        # average
        if hz > 0.0:
            try:
                self.assert_(result.msg_t0 >= 0.0, "no first message received")
                self.assert_(result.msg_tn >= 0.0, "no last message received")
                dt = result.msg_tn - result.msg_t0
                self.assert_(dt > 0.0, "only one message received")
                rate = ( result.msg_count - 1) / dt
                self.assert_(rate >= min_rate, 
                            "average rate (%.3fHz) exceeded minimum (%.3fHz)" %
                            (rate, min_rate))
                self.assert_(rate <= max_rate, 
                            "average rate (%.3fHz) exceeded maximum (%.3fHz)" %
                            (rate, max_rate))
            except AssertionError, e:
                if not current_test_failed:
                    self.verificationErrors.append('Name: %s Topic: %s Error: %s'%(test_name, topic, str(e)))
                    current_test_failed = True
    return dynamic_test_method
    
        
    # Fetch parameters
cob_hardware_test = rospy.get_param('cob_hardware_test')   
threads = []
#start threads in loop
for k, i in cob_hardware_test.iteritems():
    #self.lock = threading.Lock()
    
    #Reset for each cycle:
    #result.message_received = False
    
    test_name = k
    hz = i.get('hz')
    hzerror = i.get('hzerror')
    topic = i.get('topic')
    test_duration = i.get('test_duration')
    wait_time = i.get('wait_time')
    
    dynamic_method = create_dynamic_method(test_name, topic, hz, hzerror, test_duration, wait_time)
    dynamic_method.__name__ = 'test_{0}'.format(k)
    dynamic_method.__doc__ = 'my super great name {0}'.format(k)
    setattr(HzTest, dynamic_method.__name__, dynamic_method)
    # remove the last test name from the current namespace, 
    # so nose doesn't run it
del dynamic_method
    


            
        
if __name__ == '__main__':
    # A dirty hack to work around an apparent race condition at startup
    # that causes some hztests to fail.  Most evident in the tests of
    # rosstage.
    time.sleep(0.75)
    try:
        #rostest.run('rostest', NAME, HzTest, sys.argv)
        rosunit.unitrun('rostest', NAME, HzTest, sys.argv)
    except KeyboardInterrupt, e:
        pass
    print "exiting"

        
